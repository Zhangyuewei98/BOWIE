from __future__ import print_function
import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import copy

from astropy.cosmology import Planck15 as cosmo

from .emutils.bandpass import Bandpass
from .emutils.sed import Sed
from .emutils import signaltonoise
from .emutils.photometricparameters import PhotometricParameters
from .emutils.emtelescopesetup import EMTelescope
from .emutils.emsources import EMSource, MBHEddMag, WDMag


class EMCalc:
    def __init__(self, **kwargs):
        self.noise_interpolants = EMSNR(**kwargs)


class EMSNR:

    def __init__(self, **kwargs):

        prop_defaults = {
            'base_dir': os.path.dirname(os.path.abspath(__file__)) + '/',
            'filedir': 'emutils/em_files/seds/',
            'stdFilter': 'r',
            'signal_type': ('u', 'g', 'r', 'i', 'z'),
            'source': 'mbh',
            'telescope': None,
        }

        for prop, default in prop_defaults.items():
            setattr(self, prop, kwargs.get(prop, default))

        # stock mbh sed
        if self.source == 'mbh':
            self.sed_filename = 'quasar.gz'

        # stock wd sed
        elif self.source == 'wd':
            self.sed_filename = 'wd.gz'

        # upload filename for sed. must be in sed folder
        else:
            self.sed_filename = self.source

        if self.source is None:
            raise ValueError('source must be provided: mbh, wd, or file name in sed folder.')
        if self.telescope is None:
            raise ValueError('telescope must be provided.')

        self.filterlist = self.signal_type
        self.setup_sed()

    def setup_sed(self):
        self.sed_base = Sed()
        self.sed_base.readSED_flambda(self.base_dir + self.filedir
                                      + self.sed_filename, name=self.sed_filename)
        return


    def __call__(self, mag, z):
        # Now we'll read in each of those individual seds, into a Sed object. We'll also redshift the quasar.
        snr_out = {}
        sed = self.sed_base
        sed.redshiftSED(z)

        fluxNorm = sed.calcFluxNorm(mag, self.telescope.noise_total[self.stdFilter]['total_throughputs'])
        sed.multiplyFluxNorm(fluxNorm)

        # Calculate SNR for all seds in all filters.
        for f in self.filterlist:
            tele_info = self.telescope.noise_total[f]
            key = tele_info['telescope'] + '_' + f
            snr_out[key] = signaltonoise.calcSNR_sed(sed,
                                        tele_info['total_throughputs'], tele_info['neff'],
                                        tele_info['noise_sky_sq'],
                                        tele_info['noise_instr_sq'], self.telescope.photParams,
                                        verbose=False)
        return snr_out


def parallel_em_snr_func(num, binary_args, em_mag,
                         noise_interpolants, prefactor, verbose):
    """SNR calulation with eccentric waveforms

    Generate eddington magnitudes for MBHs and calculate their SNR for LSST in
    different bands.

    Args:
        num (int): Process number. If only a single process, num=0.
        binary_args (tuple): Binary arguments for
            :meth:`gwsnrcalc.utils.waveforms.EccentricBinaries.__call__`.
        mbheddmag (obj): Initialized class of
            :class:`gwsnrcalc.utils.lsstsnr.MBHEddMag``.
        signal_type (list of str): List with types of SNR to calculate.
            `all` for quadrature sum of modes or `modes` for SNR from each mode.
            This must be `all` if generating contour data with
            :mod:`gwsnrcalc.generate_contour_data`.
        noise_interpolants (dict): All the noise noise interpolants generated by
            :mod:`gwsnrcalc.utils.sensitivity`.
        prefactor (float): Prefactor to multiply SNR by (not SNR^2).
        verbose (int): Notify each time ``verbose`` processes finish. If -1, then no notification.

    Returns:
        (dict): Dictionary with the SNR output from the calculation.

    """
    mag, z = em_mag(*binary_args)

    out_vals = noise_interpolants(mag, z)

    if verbose > 0 and (num+1) % verbose == 0:
        print('Process ', (num+1), 'is finished.')

    return out_vals
