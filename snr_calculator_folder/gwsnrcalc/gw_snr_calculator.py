"""
Calculate gravitational wave SNRs.

This was used in "Evaluating Black Hole Detectability with LISA" (arXiv:1508.07253),
as a part of the BOWIE package (https://github.com/mikekatz04/BOWIE).

This code is licensed with the GNU public license.

This python code impliments PhenomD waveforms from Husa et al 2016 (arXiv:1508.07250)
and Khan et al 2016 (arXiv:1508.07253).

Please cite all of the arXiv papers above if you use this code in a publication.

"""

import numpy as np

from gwsnrcalc.utils.pyphenomd import PhenomDWaveforms
from gwsnrcalc.utils.csnr import csnr
from gwsnrcalc.utils.sensitivity import SensitivityContainer
from gwsnrcalc.utils.parallel import ParallelContainer


class SNR(SensitivityContainer, ParallelContainer, PhenomDWaveforms):
    """Main class for SNR calculations.

    This class performs gravitational wave SNR calculations with a matched
    filtering approach. It can generate SNRs for single sources or arrays of sources.
    It can run in parallel or on a single processor.

    Args:
        ecc (bool, optional): If True, use the eccentric SNR calculator. If False,
            use PhenomDWaveforms. (For future usage.) Default is False.
        **kwargs (dict): kwargs to be added to ParallelContainer, PhenomDWaveforms, and
            SensitivityContainer.

    Keyworkd Arguments:
        signal_type (scalar or list of str, optional): Phase of snr.
            Options are 'all' for all phases;
            'ins' for inspiral; 'mrg' for merger; or 'rd' for ringdown. Default is 'all'.
        prefactor (float, optional): Factor to multiply snr (not snr^2) integral values by.
            Default is 1.0.

    Attributes:
        snr_function (obj): Function object representing the snr function to use.
            This is form future use with other snr calculations.
        phenomdwave (obj): :class:`gwsnrcalc.utils.pyphenomd.PhenomDWaveforms`
            object for storing initial kwargs and passing to snr function.
        Note: All kwargs are stored as attributes.
        Note: Attributes are inherited from inherited classes.

    """
    def __init__(self, ecc=False, **kwargs):

        # TODO add reference to this in snr function.
        prop_defaults = {
            'prefactor': 1.0,
            'signal_type': ['all'],
        }

        for (prop, default) in prop_defaults.items():
                setattr(self, prop, kwargs.get(prop, default))

        # initialize sensitivity and parallel modules
        SensitivityContainer.__init__(self, **kwargs)
        ParallelContainer.__init__(self, **kwargs)
        self.phenomdwave = PhenomDWaveforms(**kwargs)

        # set the SNR function
        if ecc:
            pass
        else:
            self.snr_function = parallel_snr_func

    def __call__(self, *binary_args):
        """Input binary parameters and calculate the SNR

        Binary parameters are read in and adjusted based on shapes. They are then
        fed into ``run`` for calculation of the snr.

        Args:
            *args: Arguments for binary parameters (see `:meth:gwsnrcalc.utils.pyphenomd.__call__`)

        Returns:
            (dict): Dictionary with the SNR output from the calculation.

        """
        # if self.num_processors is None, run on single processor
        if self.num_processors is None:
            return self.snr_function(0, binary_args, self.phenomdwave,
                                     self.signal_type,  self.noise_interpolants,
                                     self.prefactor,  self.verbose)
        other_args = (self.phenomdwave, self.signal_type,
                      self.noise_interpolants, self.prefactor,  self.verbose)
        self.prep_parallel(binary_args, other_args)
        return self.run_parallel(self.snr_function)


def parallel_snr_func(num, binary_args, phenomdwave, signal_type,
                      noise_interpolants, prefactor, verbose):
    """SNR calulation with PhenomDWaveforms

    Generate PhenomDWaveforms and calculate their SNR against sensitivity curves.

    Args:
        num (int): Process number. If only a single process, num=0.
        binary_args (tuple): Binary arguments for :meth:`gwsnrcalc.utils.pyphenomd.__call__`.
        sensitivity_kwargs (dict): Dicitonary carrying signal_type info and
        phases (list of str): Phases from which SNR is desired. Generated by sensitivity module.
        prefactor (float): Prefactor to multiply SNR by (not SNR^2).
        num_points (int): Number of points in the generated waveforms. More points
            will asympotically converge to correct SNR value. The waveforms are log-spaced
            to conserve memory.
        verbose (int): Notify each time ``verbose`` processes finish. If -1, then no notification.

    Returns:
        (dict): Dictionary with the SNR output from the calculation.

    """

    wave = phenomdwave(*binary_args)

    out_vals = {}

    for key in noise_interpolants:
        hn_vals = noise_interpolants[key](wave.freqs)
        snr_out = csnr(wave.freqs, wave.hc, hn_vals,
                       wave.fmrg, wave.fpeak, prefactor=prefactor)

        if len(signal_type) == 1:
            out_vals[key + '_' + signal_type[0]] = snr_out[signal_type[0]]
        else:
            for phase in signal_type:
                out_vals[key + '_' + phase] = snr_out[phase]
    if verbose > 0 and (num+1) % verbose == 0:
        print('Process ', (num+1), 'is finished.')

    return out_vals


def snr(*args, **kwargs):
    """Compute the SNR of binaries.

    snr is a function that takes binary parameters and sensitivity curves as inputs,
    and returns snr for chosen phases.

    Warning: All binary parameters need to have the same shape, either scalar or 1D array.
    Start time (st), end time (et), and/or chi values can be scalars while the rest of
    the binary parameters are arrays.

    Arguments:
        *args: Arguments for :meth:`gwsnrcalc.utils.pyphenomd.PhenomDWaveforms.__call__`
        **kwargs: Keyword arguments related to
            parallel generation (see :class:`gwsnrcalc.utils.parallel`),
            waveforms (see :class:`gwsnrcalc.utils.pyphenomd`),
            or sensitivity information (see :class:`gwsnrcalc.utils.sensitivity`).

    Returns:
        (dict or list of dict): Signal-to-Noise Ratio dictionary for requested phases.

    """
    squeeze = False
    max_length = 0
    for arg in args:
        try:
            length = len(arg)
            if length > max_length:
                max_length = length

        except TypeError:
            pass

    if max_length == 0:
        squeeze = True

    kwargs['length'] = max_length

    snr_main = SNR(**kwargs)
    if squeeze:
        snr_out = snr_main(*args)
        return {key: np.squeeze(snr_out[key]) for key in snr_out}
    return snr_main(*args)
