from __future__ import print_function
import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import copy

from astropy.cosmology import Planck15 as cosmo

from .sed import Sed
from . import signaltonoise
from ..utils.sourcebase import SourceBase


class EMSource(SourceBase):

    def __init__(self, **kwargs):

        self.unit_out = 'pc'

        for key, item in kwargs.items():
            setattr(self, key, item)

    def instantiate_parallel_func(self):
        return 'parallel_em_snr_func'

    def relative_mag(self, abs_mag, distance):
        rel_mag = abs_mag + 5.*np.log10(distance) - 5.  # distance in pc
        return rel_mag

    def absolute_mag(self, lum):
        abs_mag = +4.77 - 2.5*np.log10(lum)  # lum in units of solar luminosity
        return abs_mag


class MBHEddMag(EMSource):
    def __init__(self, **kwargs):
        EMSource.__init__(self, **kwargs)

        self.set_distance_unit(dist_unit='Mpc')

        for key, item in kwargs.items():
            setattr(self, key, item)


    def _eddington_luminosity(self, mass):
        return 3e4*mass  # mass in solar masses returns solar luminosity unit

    def _sanity_check(self):
        """Check if parameters are okay.

        Sanity check makes sure each parameter is within an allowable range.

        Raises:
            ValueError: Problem with a specific parameter.

        """
        if any(self.m1 < 0.0):
            raise ValueError("Mass 1 is negative.")

        if any(self.m2 < 0.0):
            raise ValueError("Mass 2 is negative.")

        if any(self.z <= 0.0):
            raise ValueError("Redshift is zero or negative.")

        if any(self.dist <= 0.0):
            raise ValueError("Distance is zero or negative.")

        if any(self.m1 < self.m2):
            m1 = self.m1*(self.m1 >= self.m2) + self.m2*(self.m1 < self.m2)
            m2 = self.m1*(self.m1 < self.m2) + self.m2*(self.m1 >= self.m2)
            self.m1 = m1
            self.m2 = m2

        return

    def __call__(self, m1, m2, z_or_dist):
        """Calculate the detectability of EM observable.

        This assumes Eddington luminosity for smaller black hole of the pair.

        """
        self.check_if_broadcasted(locals())
        self.adjust_distances()
        # based on distance inputs, need to find redshift and luminosity distance.

        self._sanity_check()
        lum = self._eddington_luminosity(self.m2)
        abs_mag = self.absolute_mag(lum)
        rel_mag = self.relative_mag(abs_mag, self.dist)
        return rel_mag, self.z


def parallel_em_snr_func(num, params, sources, signal_type,
                         telescope, prefactor, verbose):
    """SNR calulation with eccentric waveforms

    Generate eddington magnitudes for MBHs and calculate their SNR for LSST in
    different bands.

    Args:
        num (int): Process number. If only a single process, num=0.
        binary_args (tuple): Binary arguments for
            :meth:`gwsnrcalc.utils.waveforms.EccentricBinaries.__call__`.
        mbheddmag (obj): Initialized class of
            :class:`gwsnrcalc.utils.lsstsnr.MBHEddMag``.
        signal_type (list of str): List with types of SNR to calculate.
            `all` for quadrature sum of modes or `modes` for SNR from each mode.
            This must be `all` if generating contour data with
            :mod:`gwsnrcalc.generate_contour_data`.
        noise_interpolants (dict): All the noise noise interpolants generated by
            :mod:`gwsnrcalc.utils.sensitivity`.
        prefactor (float): Prefactor to multiply SNR by (not SNR^2).
        verbose (int): Notify each time ``verbose`` processes finish. If -1, then no notification.

    Returns:
        (dict): Dictionary with the SNR output from the calculation.

    """
    mag, z = sources(*params)
    # Calculate SNR for all seds in all filters.
    snr_out = {}
    for band in signal_type:
        key = telescope.name + '_' + band
        snr_out[key] = telescope.get_snr(mag, band)

    if verbose > 0 and (num+1) % verbose == 0:
        print('Process ', (num+1), 'is finished.')

    return snr_out


class WDMag(EMSource):
    def __init__(self, **kwargs):
        EMSource.__init__(self, **kwargs)
        self.set_distance_unit(dist_unit='pc')

        for key, item in kwargs.items():
            setattr(self, key, item)

    def _sanity_check(self):
        """Check if parameters are okay.

        Sanity check makes sure each parameter is within an allowable range.

        Raises:
            ValueError: Problem with a specific parameter.

        """
        """
        if any(self.m1 > 1.4):
            raise ValueError("Mass 1 is above Chandrasekhar limit.")

        if any(self.m2 > 1.4):
            raise ValueError("Mass 2 is above Chandrasekhar limit.")

        if any(self.m1 < 0.0):
            raise ValueError("Mass 1 is below zero.")

        if any(self.m2 < 0.0):
            raise ValueError("Mass 2 is below zero.")
        """

        if any(self.dist <= 0.0):
            raise ValueError("Distance is zero or negative.")

        return

    def __call__(self, abs_mag, z_or_dist):
        """Calculate the detectability of EM observable.

        This assumes given absolute magnitude.

        *NOTE*: This assumes distance is in pc.

        """
        self.check_if_broadcasted(locals())
        self.adjust_distances()

        self._sanity_check()

        rel_mag = self.relative_mag(abs_mag, self.dist)
        return rel_mag, self.z
